# Command Center Publishing Framework (CCPF)

The **Command Center Publishing Framework** (**CCPF**) is an opinionated approach to
publishing websites using static site generators (SSGs) like Hugo.

Most SSGs, such as Hugo, do a good job with taking static files in Markdown and
similar assets but do not usually support pre-processing of page content or 
large scale page content generation from dynamic data (such as a SQL
databases or other third-party applications such as code analysis tools, ticket
management systems, and a variety of other data sources).

The CCPF's job is to fill the gaps of page generation and edge side includes
(ESIs).

Limitations:

* Only Hugo has been tested, but other SSGs should be possible.

Prerequisites:

* Linux, tested only on Ubuntu 18.04 LTS
* curl

Included:

* Jsonnet, jq, Hugo, PlantUML jar

Installed, if not available:

* Git, Graphviz

Vendored:

* Google Go, Mage, Java

## CCPF Functionality

The CCPF defines a set of strategies and utilities that allows:

* Normal processing of SSG content for site generators like Hugo. The CCPF's
  core philosophy is to build around or on top of SSGs, not replace them. For
  now, we only support Hugo but other SSGs should be easy to add later.
* Running PlantUML and generating diagrams from UML sources
* Running GraphQL and generating SSG content from the results of the queries
* Running SQL and generating content pages from the results of the queries
* Creating server-side JSON, CSV, etc. includes that can be included in SSG 
  content
* Creating client-side edge side includes (ESIs) for portions of an SSG which
  are dynamic.

## How to Install the CCPF

Intial setup in default location:

    curl https://raw.githubusercontent.com/shah/command-center-publishing-framework/master/bin/setup-CCPF.sh | bash

Intial setup in another location (e.g. /etc/CCPF):

    export CCPF_HOME=/etc/CCPF
    curl https://raw.githubusercontent.com/shah/command-center-publishing-framework/master/bin/setup-CCPF.sh | bash

## How to Upgrade the CCPF

The directory where CCPF is installed is considered read-only. Any configuration files you add should be 
placed outside of the installation directory. The **JSONNET_PATH**, **CCPF_FACTS_FILES**, and other variables 
can be used to override configuration files so that your files instead of the defaults are used. 

Therefore, to upgrade you just:

    sudo rm -rf /opt/command-center-publishing-framework
    curl https://raw.githubusercontent.com/shah/command-center-publishing-framework/master/bin/setup-CCPF.sh | bash

## Checking Dependencies

CCPF has some important dependencies. After installation, you should run:

    /opt/command-center-publishing-framework/bin/doctor.sh

## Conventions

CCPF manages SSG project files using git, make, and [Jsonnet](https://jsonnet.org/). All developers looking
to extend CCPF need to know those tools very well. The framework manages SSG projects by an 
*opinionated* set of *conventions*:

Each project is defined by files in a CCPF *Project Home* (CCPF_PROJECT_HOME) directory.
The CCPF_PROJECT_HOME can be placed anywhere but follows these conventions:

* The *name* of the **CCPF_PROJECT_HOME** directory is assumed to be the project name.
* Each **CCPF_PROJECT_HOME** directory contains, at a minium, a project.ccpf-defn.jsonnet config file.
* Each **CCPF_PROJECT_HOME** directory contains a .gitignore file which is auto-generated by the Makefile
  and makes sure that no git tracking occurs for files generated by Jsonnet.
* The **CCPF_PROJECT_HOME** directory's Makefile feeds Jsonnet a project.ccpf-defn.jsonnet and generates all necessary
  assets / artifacts.

## Scripts

* **CCPF_HOME/bin/ccpf-make** is a convenience script to run the Makefile in a **CCPF_PROJECT_HOME** if CCPF_HOME/lib/Makefile 
  is not symlink'd. This script is symlink'd as /usr/bin/ccpf-make by the installer.
* **bin/doctor.sh** is used to check dependencies and related requirements
* **bin/generate-ccpf-facts.sh** is used to create "facts" (see below) that the CCPF ecosystem can use
* **CCPF_HOME/bin/vendorize-golang-ecosystem.sh** is a convenience script create a local Google Go installation
* **CCPF_HOME/bin/vendorize-java-ecosystem.sh** is a convenience script create a local Java installation

## Environment Variables

These are the most useful environment variables to set before calling the Makefile, all of them have
sensible defaults:

* **JSONNET_PATH** is a colon-separated path which indicates where Jsonnet configs should be searched.
* **CCPF_HOME** is where the CCPF is installed (default is /opt/command-center-publishing-framework).
* **CCPF_LOG_LEVEL** should be set to INFO to see verbose messages as CCPF does its job (default is NONE).
* **CCPF_FACTS_FILES** is where CCPF stores fact files - see "Facts Generator" section below for explanation.

## Migration Makefile

Each project home ("CDH") directory may contain a Makefile which is, usually, symlink'd to
CCPF_HOME/lib/Makefile. This allows each project to have it's own Makefile but conveniently
links to a master Makefile unless the project has something special.

If the CDH does not contain a Makefile, then the **ccpf-make** convenience script may be used as a replacement.

The Makefile has a simple plugin model:

* If a file named **before_configure.ccpf-make-plugin.sh** exists in the project home directory,
  it is run right before the Makefile's configure target (*before* generating all artifacts).
* If a file named **after_configure.ccpf-make-plugin.sh** exists in the project home directory,
  it is run right after the Makefile's configure target (*after* generating all artifacts). Unlike the
  **before_configure.ccpf-make-plugin.sh**, which must already exist before the code generator process starts, the
  **after_configure.ccpf-make-plugin.sh** can be generated by Jsonnet's processing of project.ccpf-defn.jsonnet.
* If a file named **project.ccpf-make.inc** exists in the project home directory, it is
  included in the Makefile -- effectively allowing you to add targets. You can also redefine targets
  but you'll get a warning. The **project.ccpf-make.inc** may be generated as part of the code generation process.
* If a file named **after_start.make-plugin.sh** exists in the project home directory, it
  is run immediately after the *make start* target concludes. This allows you to run some post-start
  functionality like checking the health of a project or ensuring other dependencies are executed.
  The **after_start.make-plugin.sh** script can be generated by Jsonnet's processing of 
  project.ccpf-defn.jsonnet.

The Makefile has these typical targets:

* **help** shows all the targets available in the Makefile -- use that instead of this document when possible
* **doctor** evaluates the runtime environment to see if there's anything missing
* **configure** generates the project's artifacts (driven by project.ccpf-defn.jsonnet), then runs the
  **after_configure.ccpf-make-plugin.sh** shell script (if it exists)
* **clean** cleans up generated files, etc. (**DESTRUCTIVE**)

The Makefile can also have other containter-specific targets using the **project.ccpf-make.inc** feature.

In addition to the files created by Jsonnet processing of project.ccpf-defn.jsonnet, the Makefile generates 
these housekeeping files:

* **.ccpf_project.ccpf-defn.jsonnet_generated**, a text file that contains the list of files generated
* **.ccpf_delete_generated_files.sh**, which is executed by the **clean** target
* **.ccpf_facts** directory, which contains generated facts (see below)
* **.gitignore**, to make sure generated files are not tracked or committed (in case the project is git-managed)

## Facts Generator

Before the project.ccpf-defn.jsonnet file is interpreted, there are a series of "facts generator" scripts that
can be run to pre-populate configuration entries from the environment or other dynamic locations. 
Facts can be retrieved from osquery, from the environment, or as arbitrary shell scripts snippets.

The Makefile uses this script by default, but it can be overridden:

    CCPF_FACTS_GENERATOR_SCRIPT ?= $(CCPF_HOME)/bin/generate-ccpf-facts.sh

Here's an example of the default $(CCPF_HOME)/etc/facts-generator.ccpf-conf.jsonnet configuration file:

    {
        osQueries: {
            singleRow : [
                { name: "system-localhost", query: "select * from system_info" }
                { name: "eth0-interface-localhost", query: "select * from interface_addresses where interface = 'eth0'" }
            ],
            multipleRows : [
                { name: "interfaces-localhost", query: "select * from interface_addresses" }
            ],
        },

        shellEvals: [
            { name: "docker-localhost", key: "dockerHostIPAddress", evalAsTextValue: "/sbin/ip -4 -o addr show dev eth0| awk '{split(\\$4,a,\\\"/\\\");print a[1]}'" },
            { name: "docker-localhost", key: "dockerBridgeNetworkGatewayIPAddress", evalAsTextValue: "docker network inspect --format='{{range .IPAM.Config}}{{.Gateway}}{{end}}' bridge" },
        ],
    }

You can pass one or more facts generator files, colon-separated, via the CCPF_FACTS_FILES environment variable.
The default value in the Makefile calls these source files, in this order:

    $(CCPF_HOME)/etc/common.ccpf-factsgen.jsonnet
    $(CCPF_PROJECT_HOME)/project.ccpf-factsgen.jsonnet

## Configuration Files

CCPF generates Hugo config.toml, Dockerfile, docker-compose.yml, and a variety of other configuration files using Makefiles
and the [Jsonnet data templating language](https://jsonnet.org/). When Jsonnet runs, it uses the 
JSONNET_PATH Makefile variable defined in CCPF_HOME/lib/Makefile, but it can be overridden.

The default path is as follows, the earlier path in the list wins:

    $(CCPF_PROJECT_HOME)/etc
    $(CCPF_PROJECT_HOME)/lib
    $(HOME)/.ccpf/secrets
    $(HOME)/.ccpf/etc
    $(CCPF_HOME)/lib
    $(CCPF_HOME)/etc

## CCPF Suggested Project Directory Structure

The following directory structure is the recommended approach to storing
various CCPF artifacts:

* **etc**. Configuration files for binaries and scripts that are used by the
  CCPF utilities and Makefiles.
* **publication**. This directory contains the final, static content, that is 
  to be served by web servers. It could be cloned as a remote git submodule so 
  that git hooks can be created to automatically publish it to Netlify or other 
  SSG hosts when you push the latest version. Or, this directory can be the 
  source of a container-based webserver (if part of a Dockerfile multi-stage 
  build).
* **hugo-src-main**. The directory in which the content which an SSG (e.g. Hugo) 
  would typically manage on its own would reside here. This can be a remote git
  submodule for the most flexibility. For pages that are generated by CCPF, 
  content may be either directly generated in this directory or symlink'd from 
  this directory to other parts of the CCPF (e.g. **include** directory). This
  directory is called _ssg-primary_ because there may be more than one.
* **support**. CCPF documentation and other support collateral reside here.
* **tasks**. Custom Makefiles, Mage scripts, and other task runner code resides
  here.
* **vendor** directory. Google Go (e.g. Mage) and other custom libraries reside
  here. Only required during the CCPF code generation process, not in final 
  publication (which is HTML static site).
